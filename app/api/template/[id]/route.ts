import { readTemplateStructureFromJson, saveTemplateStructureToJson } from "@/features/playground/libs/path-to-json";
import { db } from "@/lib/db";
import { templatePaths } from "@/lib/template";
import path from "path";
import fs from "fs/promises";
import { NextRequest } from "next/server";

// Helper function to ensure valid JSON
function validateJsonStructure(data: unknown): boolean {
  try {
    JSON.parse(JSON.stringify(data)); // Ensures it's serializable
    return true;
  } catch (error) {
    console.error("Invalid JSON structure:", error);
    return false;
  }
}

// Helper function to check if directory exists
async function directoryExists(dirPath: string): Promise<boolean> {
  try {
    const stat = await fs.stat(dirPath);
    return stat.isDirectory();
  } catch {
    return false;
  }
}

// Create a fallback template when the actual template directory doesn't exist
function createFallbackTemplate(templateKey: string) {
  const templates: Record<string, any> = {
    NEXTJS: {
      folderName: "nextjs-project",
      items: [
        {
          filename: "package",
          fileExtension: "json",
          content: JSON.stringify({
            "name": "nextjs-project",
            "version": "0.1.0",
            "private": true,
            "scripts": {
              "dev": "next dev",
              "build": "next build",
              "start": "next start",
              "lint": "next lint"
            },
            "dependencies": {
              "next": "14.0.0",
              "react": "^18",
              "react-dom": "^18"
            },
            "devDependencies": {
              "@types/node": "^20",
              "@types/react": "^18",
              "@types/react-dom": "^18",
              "typescript": "^5"
            }
          }, null, 2)
        },
        {
          filename: "next.config",
          fileExtension: "js",
          content: `/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig`
        },
        {
          filename: "tsconfig",
          fileExtension: "json",
          content: JSON.stringify({
            "compilerOptions": {
              "target": "es5",
              "lib": ["dom", "dom.iterable", "es6"],
              "allowJs": true,
              "skipLibCheck": true,
              "strict": true,
              "noEmit": true,
              "esModuleInterop": true,
              "module": "esnext",
              "moduleResolution": "bundler",
              "resolveJsonModule": true,
              "isolatedModules": true,
              "jsx": "preserve",
              "incremental": true,
              "plugins": [
                {
                  "name": "next"
                }
              ],
              "paths": {
                "@/*": ["./*"]
              }
            },
            "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
            "exclude": ["node_modules"]
          }, null, 2)
        },
        {
          folderName: "app",
          items: [
            {
              filename: "layout",
              fileExtension: "tsx",
              content: `import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
`
            },
            {
              filename: "page",
              fileExtension: "tsx",
              content: `export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <div className="z-10 max-w-5xl w-full items-center justify-between font-mono text-sm lg:flex">
        <h1 className="text-4xl font-bold">Welcome to Next.js!</h1>
        <p className="mt-4 text-xl">
          Get started by editing{' '}
          <code className="font-mono font-weight-bold">app/page.tsx</code>
        </p>
      </div>
    </main>
  )
}
`
            },
            {
              filename: "globals",
              fileExtension: "css",
              content: `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
`
            }
          ]
        }
      ]
    },
    REACT: {
      folderName: "react-project",
      items: [
        {
          filename: "package",
          fileExtension: "json",
          content: JSON.stringify({
            "name": "react-project",
            "version": "0.1.0",
            "private": true,
            "dependencies": {
              "react": "^18.2.0",
              "react-dom": "^18.2.0"
            },
            "scripts": {
              "start": "react-scripts start",
              "build": "react-scripts build",
              "test": "react-scripts test",
              "eject": "react-scripts eject"
            }
          }, null, 2)
        },
        {
          filename: "index",
          fileExtension: "html",
          content: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>`
        },
        {
          folderName: "src",
          items: [
            {
              filename: "index",
              fileExtension: "js",
              content: `import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`
            },
            {
              filename: "App",
              fileExtension: "js",
              content: `import React from 'react';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <h1>Welcome to React!</h1>
        <p>Edit <code>src/App.js</code> and save to reload.</p>
      </header>
    </div>
  );
}

export default App;`
            },
            {
              filename: "App",
              fileExtension: "css",
              content: `.App {
  text-align: center;
}

.App-header {
  background-color: #282c34;
  padding: 20px;
  color: white;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
}

.App-header h1 {
  margin: 0 0 20px 0;
}`
            }
          ]
        }
      ]
    }
  };

  // Return the specific template or a generic fallback
  return templates[templateKey] || {
    folderName: "project",
    items: [
      {
        filename: "README",
        fileExtension: "md",
        content: `# ${templateKey} Project

This is a fallback template for ${templateKey}.

## Getting Started

This template was generated automatically because the original template directory was not found.
`
      }
    ]
  };
}

export async function GET(
  _request: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await ctx.params;

    if (!id) {
      console.error("Missing playground ID");
      return Response.json({ error: "Missing playground ID" }, { status: 400 });
    }

    console.log("Loading playground with ID:", id);

    const playground = await db.playground.findUnique({
      where: { id },
    });

    if (!playground) {
      console.error("Playground not found for ID:", id);
      return Response.json({ error: "Playground not found" }, { status: 404 });
    }

    console.log("Playground found:", playground);

    // Check if template field exists and is valid
    if (!playground.template) {
      console.error("Playground has no template specified:", id);
      return Response.json({ error: "No template specified for this playground" }, { status: 400 });
    }

    const templateValue = playground.template as string;
    console.log("Raw template value from DB:", templateValue);

    // Try to find matching template key (case-insensitive)
    let templateKey: keyof typeof templatePaths | null = null;
    let templatePath: string | null = null;

    // First try exact match
    if (templateValue in templatePaths) {
      templateKey = templateValue as keyof typeof templatePaths;
      templatePath = templatePaths[templateKey];
    } else {
      // Try case-insensitive match
      const upperTemplate = templateValue.toUpperCase();
      if (upperTemplate in templatePaths) {
        templateKey = upperTemplate as keyof typeof templatePaths;
        templatePath = templatePaths[templateKey];
      } else {
        // Try to find by matching the directory name
        for (const [key, path] of Object.entries(templatePaths)) {
          const dirName = path.split('/').pop()?.toLowerCase();
          if (dirName === templateValue.toLowerCase()) {
            templateKey = key as keyof typeof templatePaths;
            templatePath = path;
            break;
          }
        }
      }
    }

    if (!templateKey || !templatePath) {
      console.error("Invalid template value:", templateValue, "Available keys:", Object.keys(templatePaths));
      console.error("Available template paths:", Object.values(templatePaths));
      return Response.json({ 
        error: "Invalid template",
        details: `Template "${templateValue}" not found. Available templates: ${Object.keys(templatePaths).join(', ')}`
      }, { status: 404 });
    }

    const inputPath = path.join(process.cwd(), templatePath);
    const outputFile = path.join(process.cwd(), `output/${templateKey}.json`);

    console.log("Template key:", templateKey);
    console.log("Input Path:", inputPath);
    console.log("Output Path:", outputFile);

    // Check if the template directory exists
    const dirExists = await directoryExists(inputPath);
    if (!dirExists) {
      console.error("Template directory does not exist:", inputPath);
      console.log("Available directories in lileecode-starters:");
      try {
        const startersDir = path.join(process.cwd(), 'lileecode-starters');
        const dirs = await fs.readdir(startersDir);
        console.log("Available starter directories:", dirs);
      } catch (err) {
        console.log("Could not read lileecode-starters directory:", err);
      }
      
      // Return a fallback template instead of erroring out
      console.log("Returning fallback template for:", templateKey);
      const fallbackTemplate = createFallbackTemplate(templateKey);
      
      return Response.json({ 
        success: true, 
        templateJson: fallbackTemplate,
        fallback: true,
        message: `Using fallback template for ${templateKey}`
      }, { status: 200 });
    }

    // Ensure output directory exists
    const outputDir = path.dirname(outputFile);
    await fs.mkdir(outputDir, { recursive: true });

    // Save and read the template structure
    await saveTemplateStructureToJson(inputPath, outputFile);
    const result = await readTemplateStructureFromJson(outputFile);

    console.log("Template structure loaded successfully, items count:", Array.isArray(result) ? result.length : 'N/A');

    // Validate the JSON structure before returning
    if (!validateJsonStructure(result)) {
      console.error("Invalid JSON structure in result");
      return Response.json({ error: "Invalid JSON structure" }, { status: 500 });
    }

    // Clean up the temporary file
    try {
      await fs.unlink(outputFile);
    } catch (unlinkError) {
      console.warn("Could not delete temporary file:", unlinkError);
    }

    return Response.json({ success: true, templateJson: result }, { status: 200 });

  } catch (error) {
    console.error("Error in template API route:", error);
    return Response.json({ 
      error: "Failed to generate template",
      details: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 });
  }
}

export async function PUT(
  request: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await ctx.params;
    const body = await request.json();

    if (!id) {
      return Response.json({ error: "Missing playground ID" }, { status: 400 });
    }

    if (!body.templateData) {
      return Response.json({ error: "Missing template data" }, { status: 400 });
    }

    // Validate the template data structure
    if (!validateJsonStructure(body.templateData)) {
      return Response.json({ error: "Invalid template data structure" }, { status: 400 });
    }

    // Update the playground's template files in the database
    const playground = await db.playground.findUnique({
      where: { id },
    });

    if (!playground) {
      return Response.json({ error: "Playground not found" }, { status: 404 });
    }

    // Update or create template file record
    const existingFile = await db.templateFile.findFirst({
      where: { playgroundId: id }
    });

    if (existingFile) {
      await db.templateFile.update({
        where: { id: existingFile.id },
        data: { content: JSON.stringify(body.templateData) }
      });
    } else {
      await db.templateFile.create({
        data: {
          playgroundId: id,
          content: JSON.stringify(body.templateData)
        }
      });
    }

    return Response.json({ success: true, message: "Template updated successfully" }, { status: 200 });

  } catch (error) {
    console.error("Error updating template:", error);
    return Response.json({
      error: "Failed to update template",
      details: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 });
  }
}

